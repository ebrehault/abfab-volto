/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "/~/libs/svelte/internal/index.mjs";

import { getRealPath, Content } from "/~/abfab/core.js";
import AFTextarea from "/~/abfab/ui/textarea.svelte";
import AFIcon from "/~/abfab/ui/icon.svelte";
import AFButton from "/~/abfab/ui/button.svelte";
import AFDropdown from "/~/abfab/ui/dropdown.svelte";
import AFInput from "/~/abfab/ui/input.svelte";
import { onMount } from "/~/libs/svelte/index.mjs";

function add_css() {
	var style = element("style");
	style.id = "svelte-1hso7oh-style";
	style.textContent = "section.svelte-1hso7oh{margin:0 1em;width:calc(50vw - 7em)}textarea{font-family:monospace}.publish-buttons.svelte-1hso7oh{display:flex;flex-direction:column;padding:0.5em}.sync-action.svelte-1hso7oh{display:flex}";
	append(document.head, style);
}

// (70:4) {#if status}
function create_if_block_2(ctx) {
	let p;
	let t0;
	let t1_value = (/*status*/ ctx[5].published ? "Published" : "Private") + "";
	let t1;
	let t2;
	let t3_value = (/*status*/ ctx[5].inherit ? "(inherited)" : "") + "";
	let t3;
	let t4;
	let afdropdown;
	let current;

	afdropdown = new AFDropdown({
			props: {
				label: "Publish",
				icon: "pencil",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			p = element("p");
			t0 = text("Status: ");
			t1 = text(t1_value);
			t2 = space();
			t3 = text(t3_value);
			t4 = space();
			create_component(afdropdown.$$.fragment);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
			append(p, t3);
			append(p, t4);
			mount_component(afdropdown, p, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*status*/ 32) && t1_value !== (t1_value = (/*status*/ ctx[5].published ? "Published" : "Private") + "")) set_data(t1, t1_value);
			if ((!current || dirty & /*status*/ 32) && t3_value !== (t3_value = (/*status*/ ctx[5].inherit ? "(inherited)" : "") + "")) set_data(t3, t3_value);
			const afdropdown_changes = {};

			if (dirty & /*$$scope*/ 1048576) {
				afdropdown_changes.$$scope = { dirty, ctx };
			}

			afdropdown.$set(afdropdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(afdropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(afdropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			destroy_component(afdropdown);
		}
	};
}

// (75:16) <AFButton kind="primary" aspect="basic" on:click={() => share('Allow')}>
function create_default_slot_5(ctx) {
	let t;

	return {
		c() {
			t = text("Publish");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (76:16) <AFButton kind="destructive" aspect="basic" on:click={() => share('Deny')}>
function create_default_slot_4(ctx) {
	let t;

	return {
		c() {
			t = text("Unpublish");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (77:16) <AFButton kind="secondary" aspect="basic" on:click={() => share('Unset')}>
function create_default_slot_3(ctx) {
	let t;

	return {
		c() {
			t = text("Reset");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (73:8) <AFDropdown label="Publish" icon="pencil">
function create_default_slot_2(ctx) {
	let div;
	let afbutton0;
	let t0;
	let afbutton1;
	let t1;
	let afbutton2;
	let current;

	afbutton0 = new AFButton({
			props: {
				kind: "primary",
				aspect: "basic",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			}
		});

	afbutton0.$on("click", /*click_handler*/ ctx[12]);

	afbutton1 = new AFButton({
			props: {
				kind: "destructive",
				aspect: "basic",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	afbutton1.$on("click", /*click_handler_1*/ ctx[13]);

	afbutton2 = new AFButton({
			props: {
				kind: "secondary",
				aspect: "basic",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	afbutton2.$on("click", /*click_handler_2*/ ctx[14]);

	return {
		c() {
			div = element("div");
			create_component(afbutton0.$$.fragment);
			t0 = space();
			create_component(afbutton1.$$.fragment);
			t1 = space();
			create_component(afbutton2.$$.fragment);
			attr(div, "class", "publish-buttons svelte-1hso7oh");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(afbutton0, div, null);
			append(div, t0);
			mount_component(afbutton1, div, null);
			append(div, t1);
			mount_component(afbutton2, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const afbutton0_changes = {};

			if (dirty & /*$$scope*/ 1048576) {
				afbutton0_changes.$$scope = { dirty, ctx };
			}

			afbutton0.$set(afbutton0_changes);
			const afbutton1_changes = {};

			if (dirty & /*$$scope*/ 1048576) {
				afbutton1_changes.$$scope = { dirty, ctx };
			}

			afbutton1.$set(afbutton1_changes);
			const afbutton2_changes = {};

			if (dirty & /*$$scope*/ 1048576) {
				afbutton2_changes.$$scope = { dirty, ctx };
			}

			afbutton2.$set(afbutton2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(afbutton0.$$.fragment, local);
			transition_in(afbutton1.$$.fragment, local);
			transition_in(afbutton2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(afbutton0.$$.fragment, local);
			transition_out(afbutton1.$$.fragment, local);
			transition_out(afbutton2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(afbutton0);
			destroy_component(afbutton1);
			destroy_component(afbutton2);
		}
	};
}

// (82:4) {#if componentPath}
function create_if_block_1(ctx) {
	let pre;
	let t0;
	let t1;
	let p;
	let a;
	let t2;
	let aficon;
	let t3;
	let h3;
	let t5;
	let aftextarea0;
	let updating_value;
	let t6;
	let aftextarea1;
	let updating_value_1;
	let current;

	aficon = new AFIcon({
			props: { size: "small", icon: "external" }
		});

	function aftextarea0_value_binding(value) {
		/*aftextarea0_value_binding*/ ctx[15](value);
	}

	let aftextarea0_props = { label: "Web component snippet" };

	if (/*elementSnippet*/ ctx[3] !== void 0) {
		aftextarea0_props.value = /*elementSnippet*/ ctx[3];
	}

	aftextarea0 = new AFTextarea({ props: aftextarea0_props });
	binding_callbacks.push(() => bind(aftextarea0, "value", aftextarea0_value_binding));

	function aftextarea1_value_binding(value) {
		/*aftextarea1_value_binding*/ ctx[16](value);
	}

	let aftextarea1_props = { label: "iframe snippet" };

	if (/*iframeSnippet*/ ctx[2] !== void 0) {
		aftextarea1_props.value = /*iframeSnippet*/ ctx[2];
	}

	aftextarea1 = new AFTextarea({ props: aftextarea1_props });
	binding_callbacks.push(() => bind(aftextarea1, "value", aftextarea1_value_binding));

	return {
		c() {
			pre = element("pre");
			t0 = text(/*link*/ ctx[4]);
			t1 = space();
			p = element("p");
			a = element("a");
			t2 = text("Open in its own tab ");
			create_component(aficon.$$.fragment);
			t3 = space();
			h3 = element("h3");
			h3.textContent = "Embed";
			t5 = space();
			create_component(aftextarea0.$$.fragment);
			t6 = space();
			create_component(aftextarea1.$$.fragment);
			attr(a, "target", "_new");
			attr(a, "href", /*link*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, pre, anchor);
			append(pre, t0);
			insert(target, t1, anchor);
			insert(target, p, anchor);
			append(p, a);
			append(a, t2);
			mount_component(aficon, a, null);
			insert(target, t3, anchor);
			insert(target, h3, anchor);
			insert(target, t5, anchor);
			mount_component(aftextarea0, target, anchor);
			insert(target, t6, anchor);
			mount_component(aftextarea1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*link*/ 16) set_data(t0, /*link*/ ctx[4]);

			if (!current || dirty & /*link*/ 16) {
				attr(a, "href", /*link*/ ctx[4]);
			}

			const aftextarea0_changes = {};

			if (!updating_value && dirty & /*elementSnippet*/ 8) {
				updating_value = true;
				aftextarea0_changes.value = /*elementSnippet*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			aftextarea0.$set(aftextarea0_changes);
			const aftextarea1_changes = {};

			if (!updating_value_1 && dirty & /*iframeSnippet*/ 4) {
				updating_value_1 = true;
				aftextarea1_changes.value = /*iframeSnippet*/ ctx[2];
				add_flush_callback(() => updating_value_1 = false);
			}

			aftextarea1.$set(aftextarea1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(aficon.$$.fragment, local);
			transition_in(aftextarea0.$$.fragment, local);
			transition_in(aftextarea1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(aficon.$$.fragment, local);
			transition_out(aftextarea0.$$.fragment, local);
			transition_out(aftextarea1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(pre);
			if (detaching) detach(t1);
			if (detaching) detach(p);
			destroy_component(aficon);
			if (detaching) detach(t3);
			if (detaching) detach(h3);
			if (detaching) detach(t5);
			destroy_component(aftextarea0, detaching);
			if (detaching) detach(t6);
			destroy_component(aftextarea1, detaching);
		}
	};
}

// (91:4) {#if hasGit}
function create_if_block(ctx) {
	let h3;
	let t1;
	let afinput0;
	let updating_value;
	let t2;
	let div2;
	let div0;
	let h40;
	let t4;
	let p0;
	let t5;
	let code0;
	let t6;
	let t7;
	let t8;
	let afinput1;
	let updating_value_1;
	let t9;
	let div1;
	let afbutton0;
	let t10;
	let div5;
	let div3;
	let h41;
	let t12;
	let p1;
	let t13;
	let code1;
	let t14;
	let t15;
	let code2;
	let t17;
	let t18;
	let div4;
	let afbutton1;
	let current;

	function afinput0_value_binding(value) {
		/*afinput0_value_binding*/ ctx[17](value);
	}

	let afinput0_props = {
		label: "Branch",
		placeholder: "my-branch"
	};

	if (/*branch*/ ctx[6] !== void 0) {
		afinput0_props.value = /*branch*/ ctx[6];
	}

	afinput0 = new AFInput({ props: afinput0_props });
	binding_callbacks.push(() => bind(afinput0, "value", afinput0_value_binding));

	function afinput1_value_binding(value) {
		/*afinput1_value_binding*/ ctx[18](value);
	}

	let afinput1_props = {
		label: "Commit message",
		placeholder: "Short description of the changes",
		disabled: !/*branch*/ ctx[6]
	};

	if (/*commit*/ ctx[7] !== void 0) {
		afinput1_props.value = /*commit*/ ctx[7];
	}

	afinput1 = new AFInput({ props: afinput1_props });
	binding_callbacks.push(() => bind(afinput1, "value", afinput1_value_binding));

	afbutton0 = new AFButton({
			props: {
				kind: "primary",
				icon: "arrow-up",
				disabled: !/*branch*/ ctx[6],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	afbutton0.$on("click", /*push*/ ctx[9]);

	afbutton1 = new AFButton({
			props: {
				kind: "primary",
				icon: "arrow-down",
				disabled: !/*branch*/ ctx[6],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	afbutton1.$on("click", /*pull*/ ctx[10]);

	return {
		c() {
			h3 = element("h3");
			h3.textContent = "Git sync";
			t1 = space();
			create_component(afinput0.$$.fragment);
			t2 = space();
			div2 = element("div");
			div0 = element("div");
			h40 = element("h4");
			h40.textContent = "Push";
			t4 = space();
			p0 = element("p");
			t5 = text("All the changes made in this directory will be pushed to the ");
			code0 = element("code");
			t6 = text(/*branch*/ ctx[6]);
			t7 = text(" branch on your Git repository.");
			t8 = space();
			create_component(afinput1.$$.fragment);
			t9 = space();
			div1 = element("div");
			create_component(afbutton0.$$.fragment);
			t10 = space();
			div5 = element("div");
			div3 = element("div");
			h41 = element("h4");
			h41.textContent = "Pull";
			t12 = space();
			p1 = element("p");
			t13 = text("The current code from ");
			code1 = element("code");
			t14 = text(/*branch*/ ctx[6]);
			t15 = text(" branch on your Git repository will be deployed here.\n                If some changes have been made through this online inerface since the last syncing,\n                they will be pushed to the ");
			code2 = element("code");
			code2.textContent = "abfab-online-backup";
			t17 = text(" branch before any code is deployed, so nothing gets lost by mistake.");
			t18 = space();
			div4 = element("div");
			create_component(afbutton1.$$.fragment);
			attr(div2, "class", "sync-action svelte-1hso7oh");
			attr(div5, "class", "sync-action svelte-1hso7oh");
		},
		m(target, anchor) {
			insert(target, h3, anchor);
			insert(target, t1, anchor);
			mount_component(afinput0, target, anchor);
			insert(target, t2, anchor);
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, h40);
			append(div0, t4);
			append(div0, p0);
			append(p0, t5);
			append(p0, code0);
			append(code0, t6);
			append(p0, t7);
			append(div0, t8);
			mount_component(afinput1, div0, null);
			append(div2, t9);
			append(div2, div1);
			mount_component(afbutton0, div1, null);
			insert(target, t10, anchor);
			insert(target, div5, anchor);
			append(div5, div3);
			append(div3, h41);
			append(div3, t12);
			append(div3, p1);
			append(p1, t13);
			append(p1, code1);
			append(code1, t14);
			append(p1, t15);
			append(p1, code2);
			append(p1, t17);
			append(div5, t18);
			append(div5, div4);
			mount_component(afbutton1, div4, null);
			current = true;
		},
		p(ctx, dirty) {
			const afinput0_changes = {};

			if (!updating_value && dirty & /*branch*/ 64) {
				updating_value = true;
				afinput0_changes.value = /*branch*/ ctx[6];
				add_flush_callback(() => updating_value = false);
			}

			afinput0.$set(afinput0_changes);
			if (!current || dirty & /*branch*/ 64) set_data(t6, /*branch*/ ctx[6]);
			const afinput1_changes = {};
			if (dirty & /*branch*/ 64) afinput1_changes.disabled = !/*branch*/ ctx[6];

			if (!updating_value_1 && dirty & /*commit*/ 128) {
				updating_value_1 = true;
				afinput1_changes.value = /*commit*/ ctx[7];
				add_flush_callback(() => updating_value_1 = false);
			}

			afinput1.$set(afinput1_changes);
			const afbutton0_changes = {};
			if (dirty & /*branch*/ 64) afbutton0_changes.disabled = !/*branch*/ ctx[6];

			if (dirty & /*$$scope*/ 1048576) {
				afbutton0_changes.$$scope = { dirty, ctx };
			}

			afbutton0.$set(afbutton0_changes);
			if (!current || dirty & /*branch*/ 64) set_data(t14, /*branch*/ ctx[6]);
			const afbutton1_changes = {};
			if (dirty & /*branch*/ 64) afbutton1_changes.disabled = !/*branch*/ ctx[6];

			if (dirty & /*$$scope*/ 1048576) {
				afbutton1_changes.$$scope = { dirty, ctx };
			}

			afbutton1.$set(afbutton1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(afinput0.$$.fragment, local);
			transition_in(afinput1.$$.fragment, local);
			transition_in(afbutton0.$$.fragment, local);
			transition_in(afbutton1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(afinput0.$$.fragment, local);
			transition_out(afinput1.$$.fragment, local);
			transition_out(afbutton0.$$.fragment, local);
			transition_out(afbutton1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h3);
			if (detaching) detach(t1);
			destroy_component(afinput0, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(div2);
			destroy_component(afinput1);
			destroy_component(afbutton0);
			if (detaching) detach(t10);
			if (detaching) detach(div5);
			destroy_component(afbutton1);
		}
	};
}

// (103:12) <AFButton kind="primary" icon="arrow-up" on:click={push} disabled={!branch}>
function create_default_slot_1(ctx) {
	let t;

	return {
		c() {
			t = text("Push");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (116:12) <AFButton kind="primary" icon="arrow-down" on:click={pull} disabled={!branch}>
function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = text("Pull");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let section;
	let h3;
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*status*/ ctx[5] && create_if_block_2(ctx);
	let if_block1 = /*componentPath*/ ctx[0] && create_if_block_1(ctx);
	let if_block2 = /*hasGit*/ ctx[1] && create_if_block(ctx);

	return {
		c() {
			section = element("section");
			h3 = element("h3");
			h3.textContent = "Publish";
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			attr(section, "class", "svelte-1hso7oh");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			append(section, h3);
			append(section, t1);
			if (if_block0) if_block0.m(section, null);
			append(section, t2);
			if (if_block1) if_block1.m(section, null);
			append(section, t3);
			if (if_block2) if_block2.m(section, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*status*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*status*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(section, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*componentPath*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*componentPath*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(section, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*hasGit*/ ctx[1]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*hasGit*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(section, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { componentPath } = $$props;
	let { contentPath } = $$props;
	let { hasGit } = $$props;
	let iframeSnippet = "";
	let elementSnippet = "";
	let link = "";
	let status;
	let branch = "";
	let commit = "";

	onMount(async () => {
		if (!!contentPath) {
			await getStatus();
		}
	});

	async function getStatus() {
		$$invalidate(5, status = await Content.status(contentPath));
	}

	async function share(setting) {
		await Content.share(contentPath, setting);
		await getStatus();
	}

	async function push() {
		const id = contentPath.split("/").pop();

		await fetch(`/_utils/push/${id}/${branch}`, {
			method: "POST",
			body: JSON.stringify({ commit }),
			headers: {
				"Accept": "application/json",
				"Content-Type": "application/json"
			}
		});
	}

	async function pull() {
		const id = contentPath.split("/").pop();
		await fetch(`/_utils/pull/${id}/${branch}`, { method: "POST" });
	}

	const click_handler = () => share("Allow");
	const click_handler_1 = () => share("Deny");
	const click_handler_2 = () => share("Unset");

	function aftextarea0_value_binding(value) {
		elementSnippet = value;
		(($$invalidate(3, elementSnippet), $$invalidate(0, componentPath)), $$invalidate(11, contentPath));
	}

	function aftextarea1_value_binding(value) {
		iframeSnippet = value;
		(($$invalidate(2, iframeSnippet), $$invalidate(0, componentPath)), $$invalidate(11, contentPath));
	}

	function afinput0_value_binding(value) {
		branch = value;
		$$invalidate(6, branch);
	}

	function afinput1_value_binding(value) {
		commit = value;
		$$invalidate(7, commit);
	}

	$$self.$$set = $$props => {
		if ("componentPath" in $$props) $$invalidate(0, componentPath = $$props.componentPath);
		if ("contentPath" in $$props) $$invalidate(11, contentPath = $$props.contentPath);
		if ("hasGit" in $$props) $$invalidate(1, hasGit = $$props.hasGit);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*componentPath, contentPath*/ 2049) {
			$: {
				if (componentPath) {
					$$invalidate(4, link = location.origin + (contentPath
					? getRealPath(contentPath)
					: getRealPath(componentPath)));

					const _componentPath = `${location.origin}${getRealPath(componentPath)}`;

					if (contentPath) {
						const _contentPath = `${location.origin}${getRealPath(contentPath)}`;
						$$invalidate(2, iframeSnippet = `<iframe src="${_contentPath}" style="border: none; width: 100%; height: 500px;">`);

						$$invalidate(3, elementSnippet = `<script type="module" src="${location.origin}/~/abfab/element.svelte.js">
        <abfab-element contentpath="${_contentPath}" componentpath="${_componentPath}"></abfab-element>`);
					} else {
						$$invalidate(2, iframeSnippet = `<iframe src="${_componentPath}" style="border: none; width: 100%; height: 500px;">`);

						$$invalidate(3, elementSnippet = `<script type="module" src="${location.origin}/~/abfab/element.svelte.js">
        <abfab-element componentpath="${_componentPath}"></abfab-element>`);
					}
				}
			}
		}
	};

	return [
		componentPath,
		hasGit,
		iframeSnippet,
		elementSnippet,
		link,
		status,
		branch,
		commit,
		share,
		push,
		pull,
		contentPath,
		click_handler,
		click_handler_1,
		click_handler_2,
		aftextarea0_value_binding,
		aftextarea1_value_binding,
		afinput0_value_binding,
		afinput1_value_binding
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1hso7oh-style")) add_css();

		init(this, options, instance, create_fragment, safe_not_equal, {
			componentPath: 0,
			contentPath: 11,
			hasGit: 1
		});
	}
}

export default Component;