/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	action_destroyer,
	append,
	attr,
	check_outros,
	create_component,
	create_slot,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_slot
} from "/~/libs/svelte/internal/index.mjs";

import AFButton from "/~/abfab/ui/button.svelte";
import { clickOutside } from "/~/abfab/ui/clickOutside.js";

function add_css() {
	var style = element("style");
	style.id = "svelte-1ylnyqe-style";
	style.textContent = ".container.svelte-1ylnyqe{position:relative;display:inline-block}.menu.svelte-1ylnyqe{position:absolute;background-color:var(--color-neutral-primary-lightest);z-index:400;box-shadow:0 1px 0.5rem rgb(2 19 34 / 12%), 0 0 0.25rem rgb(2 19 34 / 10%);border-radius:.125rem;text-align:left}.top.svelte-1ylnyqe{bottom:2em}.bottom.svelte-1ylnyqe{top:0.5em}";
	append(document.head, style);
}

// (11:4) <AFButton kind="primary" aspect="basic" {icon} size="small"            on:click={() => showMenu = !showMenu}>
function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 1) set_data(t, /*label*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (13:4) {#if showMenu}
function create_if_block(ctx) {
	let div;
	let clickOutside_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "menu svelte-1ylnyqe");
			toggle_class(div, "top", /*toTop*/ ctx[1]);
			toggle_class(div, "bottom", !/*toTop*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(clickOutside_action = clickOutside.call(null, div)),
					listen(div, "clickoutside", /*clickoutside_handler*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], !current ? -1 : dirty, null, null);
				}
			}

			if (dirty & /*toTop*/ 2) {
				toggle_class(div, "top", /*toTop*/ ctx[1]);
			}

			if (dirty & /*toTop*/ 2) {
				toggle_class(div, "bottom", !/*toTop*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let afbutton;
	let t;
	let current;

	afbutton = new AFButton({
			props: {
				kind: "primary",
				aspect: "basic",
				icon: /*icon*/ ctx[2],
				size: "small",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	afbutton.$on("click", /*click_handler*/ ctx[5]);
	let if_block = /*showMenu*/ ctx[3] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			create_component(afbutton.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr(div, "class", "container svelte-1ylnyqe");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(afbutton, div, null);
			append(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const afbutton_changes = {};
			if (dirty & /*icon*/ 4) afbutton_changes.icon = /*icon*/ ctx[2];

			if (dirty & /*$$scope, label*/ 129) {
				afbutton_changes.$$scope = { dirty, ctx };
			}

			afbutton.$set(afbutton_changes);

			if (/*showMenu*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showMenu*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(afbutton.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(afbutton.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(afbutton);
			if (if_block) if_block.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { label = "Menu" } = $$props;
	let { toTop = false } = $$props;
	let { icon = "more-horizontal" } = $$props;
	let showMenu = false;
	const click_handler = () => $$invalidate(3, showMenu = !showMenu);
	const clickoutside_handler = () => $$invalidate(3, showMenu = false);

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("toTop" in $$props) $$invalidate(1, toTop = $$props.toTop);
		if ("icon" in $$props) $$invalidate(2, icon = $$props.icon);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	return [
		label,
		toTop,
		icon,
		showMenu,
		slots,
		click_handler,
		clickoutside_handler,
		$$scope
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1ylnyqe-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { label: 0, toTop: 1, icon: 2 });
	}
}

export default Component;